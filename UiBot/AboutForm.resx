<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema 

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="textBox1.Text" xml:space="preserve">
    <value>1. First step is to create a account on Twitch.tv that you want to use as the bot account
2. Go to your Twitch chat and mod the bot you have created
3. Go to a website or use twitches tool to generate a Access Token that has all the permissions you want the bot to have
and then copy the token info into the Access Token field on the app and then hit save

WARNING - DO NOT SHARE YOUR ACCESS TOKEN WITH ANYONE AS IT ALLOWS THEM TO USE YOUR BOT TO ACCESS YOUR TWITCH CHANNEL WITH MODERATOR PERMISSIONS. I AM NOT RESPONSABLE IF YOU SHARE THE TOKEN   

4. Enter the channel name you want the bot to join in the Channel Name field and hit save
5. You can enable any of the fun commands before or after the bot is running
6. Hit the Start button and it should connect right away if all info is correct

FOR THE GOOSE COMMAND TO WORK YOU MUST GO TO THIS SITE AND DOWNLOAD THE FILE.
https://samperson.itch.io/desktop-goose
1. Once the game is downloaded all the files inside the folder named "Goose"
2. Once the files are in there, delete the folder called "FOR MOD-MAKERS" as it opens a pop up everytime the command runs
</value>
  </data>
  <data name="textBox2.Text" xml:space="preserve">
    <value>Normal Commands:

!mybits

!traders: Displays the remaining time till traders reset.

!drop: Opens your menu and drops all your items. Has a 20-minute cooldown.

!goose: Spawns a goose to walk around your screen for 2 to 6 minutes. Has a 10-minute cooldown.

!killgoose: Kills the goose if it gets out of hand.

!help: Displays help commands.

!randomkeys: Inputs one of these keys (W, A, S, D, E, Q, C, TAB, G, 2, 3) for 250ms to 1 second. Has a cooldown ranging from 2 to 15 minutes.

!roll: Rolls a number between 1-6 and posts it in chat.

!stats: Posts stats for deaths, escapes, kills, and deaths this wipe.

!turn: Turns left or right for 2 seconds. Has a cooldown ranging from 30 seconds to 5 minutes.

!wiggle: Wiggles the mouse back and forth a few times. Has a cooldown ranging from 30 seconds to 5 minutes.

Mod Commands:

!help: Displays help commands.

!death: Records a death.

!escape: Records an escape.

!resetdeath: Resets the death count.

!pop: Shoots your gun once by left-clicking. Has a cooldown ranging from 1 to 15 minutes.

Broadcaster Commands:

!help: Displays help commands.

!hi: Says hi to the bot.

!death: Records a death.

!escape: Records an escape.

!resetdeath: Resets the death count.

!escape: Records an escape.

!resetallstats: Resets all stats, even saved death stats.
</value>
  </data>
  <data name="textBox3.Text" xml:space="preserve">
    <value>
1.0.0.03-alpha hotfix 09-11-2023
-Added catch for crashing if you connect without putting login info in
-Fixed trader menu timers to keep the timers in memory and not be cleared out as long as they run
-Started working on a automessage system - it will send and save a message, but not resend messages
-Added notification system for trader timer updates

1.0.0.3-alpha 09-10-2023
-Rebuild Commands and unified most of the timer systems
-Added in adjustable timers for each of the commands(currently you have to restart to update all the cooldowns)
-Overhauled UI to a more modern style to support expandability

-Added trader menu
	-Traders now have their own interface to track their stock resets so you dont have to run the app connected to twitch to see this info
	-Will be adding a alert system with a sound notification and some form of notification in the UI
-Reworked most of the backend to make things work with the new system

-Added Command menu
	-Added a new menu that show the commands and lets you change their cool downs and prices for bits
	-Cool downs are to be entered in how many seconds you want it to cooldown for till you can use it again. Set to 0 for no cooldown
	-Added bit payments to commands. Now when chat membered cheer with bits or pay in anyway, the bits will be added to a file with their name. When bits is enabled, the bits they have spent, can be used on a commands!
	-They can use !mybits to see how many they have
		-None of this is tested as i dont have bit payments enabled on twitch and havent enrolled in their developer thing PLEASE GIVE FEEDBACK IF THIS WORKS

-How to use is slightly out of date and will be updated soon


1.0.0.1-alpha 09-06-2023
-Added basic command features
-Added trader reset fetching and auto updating using api.tarkov.dev
-Incorporated basic ui features
-Added some fun commands to mess with your game
-Wrote How to use - may have missed some info
-Added command list
-Added show/hide info for access token and channel
-Fixed some cooldowns accidentally triggering another when certain commands are used
-Refactored most of the original code for readability
Remember to report any bugs or new feature request on the github page!</value>
  </data>
</root>